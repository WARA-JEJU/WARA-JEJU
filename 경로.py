# -*- coding: utf-8 -*-
"""경로

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1FEN42V5Hepzr3iK9bdhW6RINM1kRmVF4
"""

# google drive 마운트
from google.colab import drive
drive.mount("/content/drive")

import pandas as pd
import numpy as np
  
part = pd.read_csv('/content/drive/MyDrive/제주도 추천시스템/병합 데이터/최종 병합/최종병합/제주특별자치도_최종_병합.csv', encoding="UTF-8")

part.shape
part.head(1)

# type 확인

part.dtypes

"""# 위도 경도로 거리계산"""

pip install haversine

from haversine import haversine

# 여행지 입력

place1 = input('여행지 입력 : ')                          # 입력 : 자유렌터카

part[part['상호명'].str.contains(place1)]
place1_dt = part[part['상호명'].str.contains(place1)]

place1_dt.iat[0,6],place1_dt.iat[0,7] # 위경도 값 구하기

A = place1_dt.iat[0,1]
A_lal = place1_dt.iat[0,6],place1_dt.iat[0,7]

# 여행지 입력

place2 = input('여행지 입력 : ')                          # 입력 : 돈대표

part[part['상호명'].str.contains(place2)]
place2_dt = part[part['상호명'].str.contains(place2)]

place2_dt.iat[0,6],place2_dt.iat[0,7] # 위경도 값 구하기

B = place2_dt.iat[0,1]
B_lal = place2_dt.iat[0,6],place2_dt.iat[0,7]

# 여행지 입력

place3 = input('여행지 입력 : ')                           # 입력 : 제주교육박물관


part[part['상호명'].str.contains(place3)]
place3_dt = part[part['상호명'].str.contains(place3)]

place3_dt.iat[0,6],place3_dt.iat[0,7] # 위경도 값 구하기

C = place3_dt.iat[0,1] 

C_lal = place3_dt.iat[0,6],place3_dt.iat[0,7]

# 여행지 입력

place4 = input('여행지 입력 : ')                           # 입력 : 커피트리


part[part['상호명'].str.contains(place4)]
place4_dt = part[part['상호명'].str.contains(place4)]

place4_dt.iat[0,6],place4_dt.iat[0,7] # 위경도 값 구하기

D = place4_dt.iat[0,1] 

D_lal = place4_dt.iat[0,6],place4_dt.iat[0,7]

# 여행지 입력

place5 = input('여행지 입력 : ')                           # 입력 : 블루마운틴호텔


part[part['상호명'].str.contains(place5)]
place5_dt = part[part['상호명'].str.contains(place5)]

place5_dt.iat[0,6],place5_dt.iat[0,7] # 위경도 값 구하기

E = place5_dt.iat[0,1] 

E_lal = place5_dt.iat[0,6],place5_dt.iat[0,7]

# 거리 계산
dt_AB = haversine(A_lal, B_lal, unit = 'km') # 단위: km

# 소수 첫번째 자리까지 표기
round(dt_AB,1)

dt_AB = round(dt_AB,1)

print('{}와 {}간의 거리는 {}km 입니다.'.format(A, B, str(round(dt_AB,1))))

# 거리 계산
dt_AC = haversine(A_lal, C_lal, unit = 'km') # 단위: km

# 소수 첫번째 자리까지 표기
round(dt_AC,1)

dt_AC = round(dt_AC,1)
dt_AC

# 거리 계산
dt_AD = haversine(A_lal, D_lal, unit = 'km') # 단위: km

# 소수 첫번째 자리까지 표기
round(dt_AD,1)

dt_AD = round(dt_AD,1)
dt_AD

# 거리 계산
dt_BC = haversine(B_lal, C_lal, unit = 'km') # 단위: km

# 소수 첫번째 자리까지 표기
round(dt_BC,1)

dt_BC = round(dt_BC,1)
dt_BC

# 거리 계산
dt_BD = haversine(B_lal, D_lal, unit = 'km') # 단위: km

# 소수 첫번째 자리까지 표기
round(dt_BD,1)

dt_BD = round(dt_BD,1)
dt_BD

# 거리 계산
dt_BE = haversine(B_lal, E_lal, unit = 'km') # 단위: km

# 소수 첫번째 자리까지 표기
round(dt_BE,1)

dt_BE = round(dt_BE,1)
dt_BE

# 거리 계산
dt_CB = haversine(C_lal, B_lal, unit = 'km') # 단위: km

# 소수 첫번째 자리까지 표기
round(dt_CB,1)

dt_CB = round(dt_CB,1)
dt_CB

# 거리 계산
dt_CD = haversine(C_lal, D_lal, unit = 'km') # 단위: km

# 소수 첫번째 자리까지 표기
round(dt_CD,1)

dt_CD = round(dt_CD,1)
dt_CD

# 거리 계산
dt_CE = haversine(C_lal, E_lal, unit = 'km') # 단위: km

# 소수 첫번째 자리까지 표기
round(dt_CE,1)

dt_CE = round(dt_CE,1)
dt_CE

# 거리 계산
dt_DB = haversine(D_lal, B_lal, unit = 'km') # 단위: km

# 소수 첫번째 자리까지 표기
round(dt_DB,1)

dt_DB = round(dt_DB,1)
dt_DB

# 거리 계산
dt_DC = haversine(D_lal, C_lal, unit = 'km') # 단위: km

# 소수 첫번째 자리까지 표기
round(dt_DC,1)

dt_DC = round(dt_DC,1)
dt_DC

# 거리 계산
dt_DE = haversine(D_lal, E_lal, unit = 'km') # 단위: km

# 소수 첫번째 자리까지 표기
round(dt_DE,1)

dt_DE = round(dt_DE,1)
dt_DE

import folium

m = folium.Map(
    location=[33.362500, 126.533694],
    zoom_start=11
)

folium.Marker(list(A_lal),
              tooltip='A',
              icon=folium.Icon(color='red', icon='info-sign')).add_to(m)

folium.Marker(list(B_lal),
              tooltip='B',
              icon=folium.Icon(color='black', icon='info-sign')).add_to(m)

folium.Marker(list(C_lal),
              tooltip='C',
              icon=folium.Icon(color='pink', icon='info-sign')).add_to(m)

folium.Marker(list(D_lal),
              tooltip='D',
              icon=folium.Icon(color='green', icon='info-sign')).add_to(m)

folium.Marker(list(E_lal),
              tooltip='E',
              icon=folium.Icon(color='blue', icon='info-sign')).add_to(m)

m

graph = { 
    'A' : {'B':dt_AB, 'C':dt_AC, 'D':dt_AD},
    'B' : {'C':dt_BC, 'D':dt_BD, 'E':dt_BE},
    'C' : {'B':dt_CB, 'D':dt_CD, 'E':dt_CE},
    'D' : {'B':dt_DB, 'C':dt_DC, 'E':dt_DE},
    'E' : {}
    }

graph

import sys
sys.setrecursionlimit(10000)

import queue 

graph = {} 
infinity = float("inf") 
costs = {} 
parents = {} 
processed = [] 

# 초기화 
def init(): 
  global graph, infinity, costs, parents, processed 
  # 간선 정보 입력 
  graph = { 
    'A' : {'B':dt_AB, 'C':dt_AC, 'D':dt_AD},
    'B' : {'C':dt_BC, 'D':dt_BD, 'E':dt_BE},
    'C' : {'B':dt_CB, 'D':dt_CD, 'E':dt_CE},
    'D' : {'B':dt_DB, 'C':dt_DC, 'E':dt_DE},
    'E' : {}
    } 

  # ---------------------------------------- 
  infinity = float("inf") 
  # ------------------------------------------ 
  costs = {} # 해당 노드 최단경로 입력 
  costs["A"] = infinity
  costs["B"] = infinity 
  costs["C"] = infinity 
  costs["D"] = infinity 
  costs["E"] = infinity 
  costs["F"] = infinity 
  # ------------------------------------------- 
  parents = {} # 추적 경로를 위해 부모 설정 
  parents["B"] = None 
  parents["C"] = None 
  parents["D"] = None 
  parents["E"] = None 
  parents["F"] = None 
  # ------------------------------------------- 
  processed = [] 

# 최단 경로를 가진 노드를 구한다. 
def find_lowest_cost_node(costs): 
    lowest_cost = float("inf") 
    lowest_cost_node = None 
    for node in costs: 
      cost = costs[node] 
      if cost < lowest_cost and node not in processed: 
        lowest_cost = cost 
        lowest_cost_node = node 

    return lowest_cost_node 

# 플로이드 워셜 알고리즘 
def Floyd(graph, start, final): 
  node = start 
  costs[start] = 0 
  while node is not None: 
    cost = costs[node] 
    neighbors = graph[node] 
    for n in neighbors.keys(): 
      new_cost = cost + neighbors[n] 
      if costs[n] > new_cost:  
          costs[n] = new_cost # 갱신 
          parents[n] = node 
    processed.append(node) 
    node = find_lowest_cost_node(costs) 
    
  # 경로 추적 로직 
  trace = [] 
  current = final 
  while current != start: 
    trace.append(current) 
    current = parents[current] 
  trace.append(start) 
  trace.reverse() 

  print("=== Floyd ===") 
  print(start, "에서 ", final, "까지의 정보")
  print("최단 거리 : ", costs[final]) 
  print("경로 : ", processed)  


start= 'A'
finish= 'E'

init() 
dijkstra(graph, start, finish) 
init() 
bfs(graph, start, finish) 
init() 
Floyd(graph, start, finish) 
init() 

# 최단 거리 수치 오류가 있어서 수정 예정

# Tuple 형태인 'A_lal'을 list로 형태로 변형 -> folium.PolyLine은 list 형태로만 출력 가능해보인다

import folium

places = [list(A_lal),
          list(D_lal),
          list(C_lal),
          list(B_lal),
          list(E_lal)]

folium.PolyLine(
    locations=places,
    tooltip='PolyLine'
).add_to(m)

folium.Marker(list(A_lal),
              tooltip='A',
              icon=folium.Icon(color='red', icon='info-sign')).add_to(m)

folium.Marker(list(B_lal),
              tooltip='B',
              icon=folium.Icon(color='black', icon='info-sign')).add_to(m)

folium.Marker(list(C_lal),
              tooltip='C',
              icon=folium.Icon(color='pink', icon='info-sign')).add_to(m)

folium.Marker(list(D_lal),
              tooltip='D',
              icon=folium.Icon(color='green', icon='info-sign')).add_to(m)

folium.Marker(list(E_lal),
              tooltip='E',
              icon=folium.Icon(color='blue', icon='info-sign')).add_to(m)

m